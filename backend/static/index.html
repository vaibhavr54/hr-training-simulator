<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI-Powered HR Training Simulator</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <style>
    /* -------- layout & global -------- */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: 'Roboto', sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 20px; 
      color: #333; 
      min-height: 100vh;
    }

    /* Increased width by ~20%: 1400 -> 1680 */
    .main-container { 
      max-width: 1500px; 
      margin: 0 auto; 
      background: #f4f7f9; 
      border-radius: 12px; 
      padding: 30px; 
      box-shadow: 0 10px 40px rgba(0,0,0,0.2); 
    }

    h2 { color: #2c3e50; margin-bottom: 30px; font-size: 32px; text-align: center; font-weight: 700; }
    h3 { color: #34495e; margin-bottom: 15px; font-size: 20px; font-weight: 600; }

    /* Keep both panels aligned to top */
    .container { display: flex; gap: 30px; flex-wrap: nowrap; align-items: flex-start; }

    /* Use proportional widths for a balanced look */
    .left-panel { flex: 0 0 52%; min-width: 420px; }
    .right-panel { flex: 0 0 48%; min-width: 380px; max-height: 1100px; overflow-y: auto; }

    label { display: block; margin-bottom: 15px; font-weight: 500; color: #2c3e50; }

    input[type="text"], input[type="number"], select {
      width: 100%;
      padding: 12px;
      margin-top: 8px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 14px;
      transition: border-color 0.3s;
    }
    input[type="text"]:focus, input[type="number"]:focus, select:focus {
      outline: none;
      border-color: #667eea;
    }

    .card {
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      margin-top: 8px;
      min-height: 60px;
    }

    /* -------- Avatar improvements -------- */
    .avatar-box { display:flex; align-items:center; gap:16px; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 15px; }
    .avatar { width: 110px; height: 110px; background: radial-gradient(circle at 30% 20%, #fff4db 0%, #ffd89b 25%, #ff9a6b 60%, #ff7e5f 100%); border-radius: 50%; display: flex; align-items:center; justify-content:center; position: relative; box-shadow: 0 10px 30px rgba(0,0,0,0.15); flex-shrink: 0; transition: box-shadow 160ms ease, transform 160ms ease; border: 3px solid rgba(255,255,255,0.35); }
    .avatar.speaking { box-shadow: 0 14px 40px rgba(102,126,234,0.25); transform: translateY(-2px) scale(1.01); }

    /* sweet cheeks */
    .avatar::after { content: ''; position:absolute; bottom:18px; left:20px; width:16px; height:8px; background: rgba(255,255,255,0.15); border-radius: 8px; filter: blur(2px); }

    /* eyebrows */
    .brow { position:absolute; top:26px; width:32px; height:6px; background: #3b3b3b; border-radius: 6px; transform-origin:center; transition: transform 160ms ease; }
    .brow.left { left:16px; transform: rotate(-6deg); }
    .brow.right { right:16px; transform: rotate(6deg); }

    /* eyes */
    .eye { width: 13px; height: 13px; background: #111; border-radius: 50%; position:absolute; top:40px; transition: transform 160ms ease; }
    .eye.left { left: 32px; }
    .eye.right { right: 32px; }

    /* blink state */
    .eye.blink { transform: scaleY(0.15); }

    /* mouth: tooth + tongue visual */
    .mouth { position: absolute; bottom: 22px; width: 44px; height: 12px; background: linear-gradient(#2f2f2f,#1a1a1a); border-radius: 20px; transition: all 90ms linear; overflow: hidden; display:flex; align-items:center; justify-content:center; }
    .mouth .tongue { width:34px; height:34px; background: radial-gradient(circle at 50% 30%, #ff8a9a 0%, #ff4d6e 50%); border-radius: 50%; transform: translateY(16px); transition: transform 110ms linear; opacity: 0; }
    .avatar.speaking .mouth { height: 26px; }
    .avatar.speaking .mouth .tongue { transform: translateY(2px); opacity: 1; }

    /* small mic icon */
    .mic { position:absolute; right: -8px; bottom: -8px; width:28px; height:28px; background: linear-gradient(180deg,#667eea,#764ba2); border-radius:6px; display:flex; align-items:center; justify-content:center; color:white; font-weight:700; box-shadow: 0 4px 12px rgba(0,0,0,0.18); font-size:12px; }

    .avatar-info { flex:1; }
    .avatar-info .name { font-weight:700; margin-bottom:8px; font-size:16px; color:#2c3e50; }
    .controls-row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .controls-row label { display:flex; align-items:center; gap:6px; margin:0; font-size:14px; cursor:pointer; }
    .controls-row input[type="checkbox"] { width:auto; cursor:pointer; }
    .avatar-description { margin-top:8px; font-size:13px; color:#555; line-height:1.4; }

    /* small pulse when feedback arrives */
    .avatar.pulse { animation: avatarPulse 700ms ease; }
    @keyframes avatarPulse {
      0% { box-shadow: 0 10px 30px rgba(102,126,234,0.16); transform: scale(1); }
      50% { box-shadow: 0 18px 50px rgba(102,126,234,0.28); transform: scale(1.03); }
      100% { box-shadow: 0 10px 30px rgba(102,126,234,0.16); transform: scale(1); }
    }

    /* -------- visual-hiding for sections we don't want printed --------
       They remain in DOM for accessibility but are visually hidden */
    .visually-hidden {
      border: 0 !important;
      clip: rect(0 0 0 0) !important;
      -webkit-clip-path: inset(50%) !important;
      clip-path: inset(50%) !important;
      height: 1px !important;
      width: 1px !important;
      margin: -1px !important;
      overflow: hidden !important;
      padding: 0 !important;
      position: absolute !important;
      white-space: nowrap !important;
    }

    /* Keep the small status bar for user, but not details */
    #currentQuestionStatus { font-size:15px; font-weight:600; color:#2c3e50; margin-top:8px; }

    /* -------- rest of UI (kept from your file) -------- */
    .meta-row { display:flex; gap:20px; align-items:flex-end; margin-bottom:15px; }
    .meta-row > div { flex:1; }
    #timerDisplay { background: white; padding:15px; border-radius:8px; text-align:center; font-size:24px; font-weight:700; color:#2c3e50; box-shadow:0 2px 8px rgba(0,0,0,0.1); margin-top:8px; }
    #preview { width:100%; max-height:400px; border-radius:8px; background:#000; margin-bottom:15px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .button-status-container { display:flex; flex-direction:column; gap:15px; }
    button { padding:14px 24px; font-size:16px; font-weight:600; border:none; border-radius:8px; cursor:pointer; transition:all 0.3s; box-shadow:0 2px 8px rgba(0,0,0,0.1); }
    #startBtn { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
    #stopBtn { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; }
    #sortBtn { padding:8px 16px; font-size:14px; background:#667eea; color:white; }
    .status { padding:12px; border-radius:8px; text-align:center; font-weight:500; background:#e3f2fd; color:#1976d2; }
    .status.error { background:#ffebee; color:#c62828; }
    .status.success { background:#e8f5e9; color:#2e7d32; }
    .spinner { border:3px solid #f3f3f3; border-top:3px solid #667eea; border-radius:50%; width:30px; height:30px; animation: spin 1s linear infinite; margin:10px auto; }
    @keyframes spin { 0%{transform:rotate(0deg);} 100%{transform:rotate(360deg);} }

    .chart-container { position:relative; height:300px; margin-bottom:15px; }
    .feedback { padding:15px; background:#f8f9fa; border-radius:8px; line-height:1.6; color:#495057; }
    .history-item { background:white; padding:15px; margin-bottom:15px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.1); border-left:4px solid #667eea; }
    .history-item h4 { color:#2c3e50; margin-bottom:8px; font-size:16px; }
    .history-item p { margin:4px 0; font-size:14px; color:#666; }
    .history-item .scores { display:grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap:10px; margin-top:10px; }
    .history-item .score-badge { padding:8px; background:#e3f2fd; border-radius:6px; text-align:center; font-size:13px; }

    .error-message { background:#ffebee !important; color:#c62828 !important; border:2px solid #ef5350 !important; }

    @media (max-width: 980px) {
      .container { flex-direction: column; }
      .left-panel, .right-panel { flex: 1 1 auto; min-width: auto; max-height: none; overflow: visible; }
      .main-container { padding: 18px; }
    }
  </style>
</head>
<body>
  <div class="main-container">
    <h2>AI-Powered HR Training Simulator</h2>

    <div class="container">
      <!-- LEFT PANEL -->
      <div class="left-panel">
        <label>üë§ Candidate Name:
          <input id="candidate" type="text" placeholder="Enter your name" autocomplete="name"/>
        </label>

        <label>üíº Role:
          <select id="roleSelect">
            <option value="General">General HR Interview</option>
            <option value="Software Engineer">Software Engineer</option>
            <option value="Data Scientist">Data Scientist</option>
            <option value="Product Manager">Product Manager</option>
            <option value="Marketing Manager">Marketing Manager</option>
            <option value="Sales Executive">Sales Executive</option>
            <option value="UX Designer">UX Designer</option>
            <option value="QA Engineer">QA Engineer</option>
            <option value="Business Analyst">Business Analyst</option>
            <option value="HR Specialist">HR Specialist</option>
            <option value="Operations Manager">Operations Manager</option>
            <option value="Finance Analyst">Finance Analyst</option>
            <option value="Content Writer">Content Writer</option>
            <option value="Data Engineer">Data Engineer</option>
            <option value="Project Manager">Project Manager</option>
          </select>
        </label>

        <div class="avatar-box card" aria-hidden="false">
          <div class="avatar" id="avatar" role="img" aria-label="Interviewer avatar">
            <div class="brow left"></div>
            <div class="brow right"></div>
            <div class="eye left" id="eyeL"></div>
            <div class="eye right" id="eyeR"></div>
            <div class="mouth" id="avatarMouth"><div class="tongue"></div></div>
            <div class="mic">üé§</div>
          </div>

          <div class="avatar-info">
            <div class="name">Interviewer Avatar</div>
            <div class="controls-row">
              <label><input type="checkbox" id="voiceToggle" checked/> Enable voice</label>
              <label><input type="checkbox" id="lipSyncToggle" checked/> Lip-sync</label>
            </div>
            <div class="avatar-description">
              Avatar will speak questions and provide spoken feedback during the interview. Visual details are intentionally hidden to avoid clutter.
            </div>
            <!-- A small single-line status (kept, not detailed). -->
            <div id="currentQuestionStatus" class="card" style="margin-top:10px;">Waiting for question (avatar will speak)</div>
          </div>
        </div>

        <!-- We keep these DOM nodes for compatibility but hide their contents visually -->
        <!-- <label>‚ùì Current Question:
          <div id="currentQuestion" class="card visually-hidden">Select a role to fetch your first question</div>
        </label>

        <label>üéôÔ∏è Live Technical Feedback:
          <div id="liveEmotionFeedback" class="card visually-hidden">
            <div id="emotionStatus">Ready to start...</div>
            <ul id="liveFeedbackList"></ul>
          </div>
        </label>

        <label>üé≠ Live Emotion Insights:
          <div id="liveEmotionInsights" class="card visually-hidden">
            <div id="emotionInsightStatus">Waiting to analyze emotions...</div>
            <ul id="emotionInsightList"></ul>
          </div>
        </label> -->

        <div class="meta-row">
          <div>
            <label>‚è±Ô∏è Time per answer (minutes)</label>
            <input id="timePerAnswer" type="number" min="1" max="10" value="2"/>
          </div>
          <div style="min-width:140px;">
            <label>‚è∞ Timer</label>
            <div id="timerDisplay">00:00</div>
          </div>
        </div>

        <video id="preview" autoplay playsinline muted></video>

        <div class="button-status-container">
          <button id="startBtn">üé• Start Recording</button>
          <button id="stopBtn" disabled>‚èπÔ∏è Stop & Upload</button>
          <div id="status" class="status"></div>
        </div>
      </div>

      <!-- RIGHT PANEL -->
      <div class="right-panel">
        <h3>üìä Feedback & Scores:</h3>
        <div id="scoreBox" class="card">
          <div class="chart-container"><canvas id="scoreChart"></canvas></div>
          <div id="feedbackText" class="feedback">Complete an interview to see your scores</div>
        </div>

        <h3>üòÉ Emotional Analysis:</h3>
        <div id="emotionBox" class="card">
          <div class="chart-container" style="height:250px;"><canvas id="emotionChart"></canvas></div>
          <div id="emotionFeedback" class="feedback">Emotion analysis will appear here</div>
        </div>

        <h3>üìù Transcript:</h3>
        <div id="transcriptBox" class="card">Your answer transcript will appear here after recording</div>

        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px;">
          <h3 style="margin:0;">üìö Past Attempts:</h3>
          <button id="sortBtn">‚¨áÔ∏è Newest first</button>
        </div>

        <div id="history"></div>
      </div>
    </div>
  </div>

<script>
/* ========== Core DOM refs ========== */
const preview = document.getElementById('preview');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const status = document.getElementById('status');
const candidate = document.getElementById('candidate');
const transcriptBox = document.getElementById('transcriptBox');
const roleSelect = document.getElementById('roleSelect');
const currentQuestionDiv = document.getElementById('currentQuestion');
const currentQuestionStatus = document.getElementById('currentQuestionStatus');
const timePerAnswer = document.getElementById('timePerAnswer');
const timerDisplay = document.getElementById('timerDisplay');
const historyContainer = document.getElementById('history');
const sortBtn = document.getElementById('sortBtn');
const avatarEl = document.getElementById('avatar');
const mouthEl = document.getElementById('avatarMouth');
const eyeL = document.getElementById('eyeL');
const eyeR = document.getElementById('eyeR');
const voiceToggle = document.getElementById('voiceToggle');
const lipSyncToggle = document.getElementById('lipSyncToggle');
const emotionInsightList = document.getElementById('emotionInsightList');
const emotionInsightStatus = document.getElementById('emotionInsightStatus');
const liveFeedbackList = document.getElementById('liveFeedbackList');

/* ========== State ========== */
let mediaStream = null;
let recorder = null;
let chunks = [];
let countdownInterval = null;
let remainingSeconds = 0;
let scoreChart = null;
let emotionChart = null;
let lastQuestion = null;
let historySortOrder = "newest";
let faceDetectionInterval = null;
let audioAnalysisInterval = null;
let emotionDetectionInterval = null;
let isRecording = false;
let audioContext = null;
let analyser = null;
let recordingStartTime = 0;
let emotionInsights = [];
let feedbackMessages = { volume: null, emotion: null, positioning: null, duration: null };

/* ========== Speech synthesis & avatar animation ========== */
const synth = window.speechSynthesis;
let selectedVoice = null;
const lastSpoken = {};
const SPEECH_COOLDOWN = 5000;

// voice chooser (prefer en-US)
function chooseVoice(preferLang = 'en-US') {
  const voices = synth.getVoices();
  if (!voices || voices.length === 0) return null;
  let v = voices.find(v => v.lang && v.lang.startsWith(preferLang));
  if (!v) v = voices[0];
  return v;
}

// mouth pulsing helper ‚Äî we animate css class; optionally we can adjust intensity
function startAvatarSpeaking() {
  if (lipSyncToggle.checked) {
    avatarEl.classList.add('speaking');
  }
}
function stopAvatarSpeaking() {
  avatarEl.classList.remove('speaking');
}

// blink cycle
(function blinkLoop() {
  const blink = () => {
    eyeL.classList.add('blink'); eyeR.classList.add('blink');
    setTimeout(() => { eyeL.classList.remove('blink'); eyeR.classList.remove('blink'); }, 120);
    // next blink after random 2.5-6s
    setTimeout(blink, 2500 + Math.random() * 3500);
  };
  setTimeout(blink, 1000 + Math.random() * 1000);
})();

// small pulse effect to indicate incoming spoken feedback
function pulseAvatar() {
  avatarEl.classList.add('pulse');
  setTimeout(() => avatarEl.classList.remove('pulse'), 800);
}

// speak text via browser TTS, throttle duplicates
function speakText(text, options = {}) {
  if (!voiceToggle.checked || !('speechSynthesis' in window)) return;
  const key = options.key || text.slice(0,20);
  const now = Date.now();
  if (lastSpoken[key] && (now - lastSpoken[key]) < (options.cooldown || SPEECH_COOLDOWN)) return;
  lastSpoken[key] = now;

  const utter = new SpeechSynthesisUtterance(text);
  if (!selectedVoice) selectedVoice = chooseVoice();
  if (selectedVoice) utter.voice = selectedVoice;
  utter.rate = options.rate || 1;
  utter.pitch = options.pitch || 1;

  utter.onstart = () => startAvatarSpeaking();
  utter.onend = () => stopAvatarSpeaking();
  utter.onerror = () => stopAvatarSpeaking();

  // cancel any queued short utterances, then speak
  synth.cancel();
  synth.speak(utter);

  // visual pulse for feedback
  pulseAvatar();
}

/* Speak the question but DO NOT print it to the screen (per request) */
function speakQuestion(q) {
  if (!q) return;
  currentQuestionStatus.textContent = 'Avatar speaking...';
  speakText(q, { key: 'question', rate: 1 });
  // clear status after a short time (silently)
  setTimeout(()=> { currentQuestionStatus.textContent = 'Waiting for next question (avatar will speak)'; }, Math.max(2500, q.length*40));
}

/* ========== IMPORTANT: don't render the detailed feedback lists on UI ========== */
/* updateFeedback and addEmotionInsight will only speak and pulse avatar.
   They won't append long lists to the DOM (we kept DOM nodes but visually hidden). */

function updateFeedback(type, message) {
  feedbackMessages[type] = message;
  // no UI list update; only speak selected concise feedback and pulse avatar
  if (message) {
    const speakable = ['volume', 'positioning', 'duration', 'emotion'];
    if (speakable.includes(type)) {
      speakText(message, { key: `fb_${type}` });
    }
  }
}

function addEmotionInsight(insight) {
  if (!insight) return;
  // dedupe: don't repeat same type too often
  const now = Date.now();
  const recent = emotionInsights.filter(i => i.type === insight.type && (now - (i.timestamp||0)) < 10000);
  if (recent.length > 0) return;
  emotionInsights.push(insight);
  // speak high priority insights only
  if (insight.priority <= 2) {
    speakText(insight.message, { key: `insight_${insight.type}`, cooldown: 8000 });
  }
  pulseAvatar();
  // optionally keep a lightweight visible log (hidden DOM preserved)
  // we purposely *don't* append visible DOM items here per your request
}

/* ========== Fetch question (no visual printing) ========= */
async function fetchNextQuestion(lastAnswer = null) {
  const form = new FormData();
  form.append("candidate", candidate.value || "unknown");
  form.append("role", roleSelect.value || "General");
  if (lastAnswer) form.append("last_answer", lastAnswer);
  // show spinner status but do not print question
  currentQuestionStatus.textContent = 'Fetching question...';
  try {
    const res = await fetch("/next-question", { method: "POST", body: form });
    if (!res.ok) throw new Error('Failed to fetch question');
    const data = await res.json();
    lastQuestion = data.question;
    // do not set currentQuestionDiv.innerText or visible text ‚Äî only speak it:
    speakQuestion(lastQuestion);
    currentQuestionStatus.textContent = 'Avatar speaking...';
  } catch (err) {
    console.error('Question fetch error:', err);
    currentQuestionStatus.textContent = '[Error fetching question ‚Äî avatar may use a fallback]';
    setTimeout(()=> currentQuestionStatus.textContent = 'Waiting for question (avatar will speak)', 3000);
  }
}

/* ========== Media init & real-time analysis (kept behavior) ========= */
async function initMedia() {
  try {
    mediaStream = await navigator.mediaDevices.getUserMedia({
      video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: 'user' },
      audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
    });
    preview.srcObject = mediaStream;
    status.textContent = '‚úÖ Camera & microphone ready';
    status.className = 'status';
  } catch (err) {
    console.error('Media access error:', err);
    status.textContent = '‚ùå Cannot access camera/mic: ' + err.message;
    status.className = 'status error';
    alert("Please allow camera and microphone access to use this application.");
  }
}

/* Audio analysis (keeps speaking feedback) */
function startAudioAnalysis() {
  if (!mediaStream) return;
  try {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    const source = audioContext.createMediaStreamSource(mediaStream);
    source.connect(analyser);
    analyser.fftSize = 256;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    let lowVolumeCount = 0;
    audioAnalysisInterval = setInterval(() => {
      if (!isRecording) return;
      analyser.getByteFrequencyData(dataArray);
      const average = dataArray.reduce((a,b)=>a+b,0)/bufferLength;
      if (average < 30) {
        lowVolumeCount++;
        if (lowVolumeCount > 3) {
          updateFeedback('volume', 'üîá Volume is low. Please speak louder and clearly.');
        }
      } else {
        lowVolumeCount = 0;
        updateFeedback('volume', null);
      }
    }, 1200);
  } catch (err) {
    console.error('Audio analysis error:', err);
  }
}
function stopAudioAnalysis() {
  if (audioAnalysisInterval) { clearInterval(audioAnalysisInterval); audioAnalysisInterval = null; }
  if (audioContext) { audioContext.close(); audioContext = null; }
}

/* Face detection (keeps speaking feedback when face missing) */
function startLiveFaceDetection() {
  let noFaceCount = 0;
  faceDetectionInterval = setInterval(() => {
    if (!isRecording) return;
    // if face-api is available we would use it; for now keep the simulated logic
    const faceDetected = Math.random() > 0.08; // simulation
    if (!faceDetected) {
      noFaceCount++;
      if (noFaceCount > 2) {
        updateFeedback('positioning', '‚ö†Ô∏è Face not clearly visible. Adjust your camera and lighting.');
        addEmotionInsight({ type:'no_face', message: 'Please adjust camera/lighting', priority:1, timestamp:Date.now() });
      }
    } else {
      noFaceCount = 0;
      updateFeedback('positioning', null);
    }
  }, 2500);
}
function stopLiveFaceDetection() { if (faceDetectionInterval) { clearInterval(faceDetectionInterval); faceDetectionInterval = null; } }

/* Emotion detection (keeps speaking higher priority insights) */
function startLiveEmotionDetection() {
  emotionDetectionInterval = setInterval(() => {
    if (!isRecording) return;
    const emotions = ['happy','neutral','sad','surprised'];
    const randomEmotion = emotions[Math.floor(Math.random()*emotions.length)];
    if (randomEmotion === 'sad') {
      addEmotionInsight({ type:'sad', message:'Try to project more confidence and positivity.', priority:2, timestamp:Date.now() });
    } else if (randomEmotion === 'happy') {
      addEmotionInsight({ type:'positive', message:'Good energy‚Äîkeep it up!', priority:3, timestamp:Date.now() });
    }
  }, 4800);
}
function stopLiveEmotionDetection(){ if (emotionDetectionInterval) { clearInterval(emotionDetectionInterval); emotionDetectionInterval = null; } }

/* Timer & Recording (kept same behavior but wire to new avatar speaking) */
function updateTimerDisplay() {
  const mins = Math.floor(remainingSeconds/60).toString().padStart(2,'0');
  const secs = (remainingSeconds%60).toString().padStart(2,'0');
  timerDisplay.textContent = `${mins}:${secs}`;
}
function startTimer() {
  const minutes = parseInt(timePerAnswer.value) || 2;
  remainingSeconds = minutes * 60;
  updateTimerDisplay();
  countdownInterval = setInterval(()=> {
    remainingSeconds--;
    updateTimerDisplay();
    if (remainingSeconds === 30) {
      updateFeedback('duration', '‚è∞ 30 seconds remaining');
      speakText('30 seconds remaining', { key: 'timer_30' });
    } else if (remainingSeconds === 10) {
      updateFeedback('duration', '‚ö†Ô∏è 10 seconds left! Wrap up.');
      speakText('10 seconds remaining', { key: 'timer_10' });
    }
    if (remainingSeconds <= 0) stopRecording();
  }, 1000);
}
function stopTimer() { if (countdownInterval) { clearInterval(countdownInterval); countdownInterval=null; } timerDisplay.textContent='00:00'; }

/* Recorder */
function startRecording() {
  if (!mediaStream) { alert('Media not initialized'); return; }
  if (!candidate.value.trim()) { alert('Please enter your name'); return; }
  if (!lastQuestion) { alert('Please wait for a question to load'); return; }

  chunks = []; emotionInsights = []; feedbackMessages = { volume:null, emotion:null, positioning:null, duration:null };
  recorder = new MediaRecorder(mediaStream, { mimeType: 'video/webm;codecs=vp8,opus' });
  recorder.ondataavailable = (e) => { if (e.data.size>0) chunks.push(e.data); };
  recorder.onstop = uploadVideo;
  recorder.start(1000);
  isRecording = true;
  recordingStartTime = Date.now();
  startBtn.disabled = true; stopBtn.disabled = false;
  status.textContent = 'üî¥ Recording in progress...'; status.className = 'status';
  startTimer();
  startAudioAnalysis();
  startLiveFaceDetection();
  startLiveEmotionDetection();
  // small audible confirmation
  speakText('Recording started. Answer the question when ready.', { key: 'record_start' });
}

function stopRecording() {
  if (!recorder || recorder.state === 'inactive') return;
  recorder.stop();
  isRecording = false;
  startBtn.disabled = false; stopBtn.disabled = true;
  status.textContent = '‚èπÔ∏è Recording stopped. Processing...'; status.className = 'status';
  stopTimer();
  stopAudioAnalysis();
  stopLiveFaceDetection();
  stopLiveEmotionDetection();
  speakText('Recording stopped. Uploading for analysis.', { key: 'record_stop' });
}

/* Upload */
async function uploadVideo() {
  const blob = new Blob(chunks, { type: 'video/webm' });
  const fd = new FormData();
  fd.append('file', blob, `interview_${Date.now()}.webm`);
  fd.append('candidate', candidate.value);
  fd.append('role', roleSelect.value);
  fd.append('last_question', lastQuestion || '');
  status.textContent = 'üì§ Uploading and analyzing...'; status.className='status';
  try {
    const res = await fetch('/upload-audio', { method:'POST', body: fd });
    if (!res.ok) throw new Error(`Upload failed: ${res.statusText}`);
    const result = await res.json();
    if (result.status === 'ok') {
      status.textContent = '‚úÖ Analysis complete!'; status.className='status success';
      displayResults(result);
      await loadHistory();
      setTimeout(()=> fetchNextQuestion(result.transcript), 1200);
    } else throw new Error(result.message || 'Unknown error');
  } catch (err) {
    console.error('Upload error', err);
    status.textContent = `‚ùå Error: ${err.message}`; status.className = 'status error';
  }
}

/* Display results (no change to behaviors) */
function displayResults(result) {
  transcriptBox.textContent = result.transcript || 'No transcript available';
  if (result.score) updateScoreChart(result.score);
  if (result.emotions) {
    updateEmotionChart(result.emotions);
    const dom = document.getElementById('emotionFeedback');
    dom.innerHTML = `<strong>Dominant Emotion:</strong> ${result.emotions.dominant_emotion || 'N/A'}<br><strong>Confidence Score:</strong> ${result.emotions.confidence_score || 'N/A'}/100<br><strong>Frames Analyzed:</strong> ${result.emotions.frames_analyzed || 0}`;
  }
}

/* charts (kept) */
function updateScoreChart(scores) {
  const ctx = document.getElementById('scoreChart').getContext('2d');
  if (scoreChart) scoreChart.destroy();
  scoreChart = new Chart(ctx, {
    type:'bar',
    data: {
      labels: ['Communication','Confidence','Structure','Soft Skills'],
      datasets: [{ label:'Score', data: [scores.communication||0, scores.confidence||0, scores.structure||0, scores.soft_skills||0],
        backgroundColor:['rgba(102,126,234,0.7)','rgba(118,75,162,0.7)','rgba(255,127,80,0.7)','rgba(46,213,115,0.7)'],
        borderColor:['rgb(102,126,234)','rgb(118,75,162)','rgb(255,127,80)','rgb(46,213,115)'], borderWidth:2
      }]
    },
    options: { responsive:true, maintainAspectRatio:false, scales:{ y:{ beginAtZero:true, max:100 } }, plugins:{legend:{display:false}} }
  });
}
function updateEmotionChart(emotionData) {
  const ctx = document.getElementById('emotionChart').getContext('2d');
  if (emotionChart) emotionChart.destroy();
  const distribution = emotionData.emotion_distribution || {};
  const labels = Object.keys(distribution);
  const data = Object.values(distribution);
  emotionChart = new Chart(ctx, {
    type:'doughnut',
    data:{ labels, datasets:[{ data, backgroundColor:['rgba(255,206,86,0.7)','rgba(75,192,192,0.7)','rgba(255,99,132,0.7)','rgba(153,102,255,0.7)','rgba(255,159,64,0.7)','rgba(54,162,235,0.7)'] }]},
    options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{position:'bottom'}}}
  });
}

/* History (kept behavior) */
async function loadHistory() {
  const candidateName = candidate.value.trim();
  if (!candidateName) { historyContainer.innerHTML = '<div class="card"><em>Enter your name to view history</em></div>'; return; }
  try {
    const res = await fetch(`/history/${encodeURIComponent(candidateName)}`);
    const data = await res.json();
    if (data.error) { historyContainer.innerHTML = `<div class="card error-message">${data.error}</div>`; return; }
    let attempts = data.history || [];
    if (attempts.length === 0) { historyContainer.innerHTML = '<div class="card"><em>No previous attempts found</em></div>'; return; }
    if (historySortOrder === 'oldest') attempts.reverse();
    historyContainer.innerHTML = attempts.map(a => {
      const score = a.score||{};
      const timestamp = new Date(a.timestamp).toLocaleString();
      return `<div class="history-item"><h4>${a.role} - ${timestamp}</h4><p><strong>Question:</strong> ${(a.last_question||'N/A').slice(0,80)}</p><div class="scores"><div class="score-badge"><strong>Communication</strong><br>${score.communication||0}</div><div class="score-badge"><strong>Confidence</strong><br>${score.confidence||0}</div><div class="score-badge"><strong>Structure</strong><br>${score.structure||0}</div><div class="score-badge"><strong>Soft Skills</strong><br>${score.soft_skills||0}</div></div></div>`;
    }).join('');
  } catch (err) {
    console.error('History load error', err);
    historyContainer.innerHTML = '<div class="card error-message">Failed to load history</div>';
  }
}

/* ========== event wiring ========== */
startBtn.addEventListener('click', startRecording);
stopBtn.addEventListener('click', stopRecording);
roleSelect.addEventListener('change', ()=>{ if (roleSelect.value) fetchNextQuestion(); });
sortBtn.addEventListener('click', ()=>{ historySortOrder = historySortOrder==='newest'?'oldest':'newest'; sortBtn.textContent = historySortOrder==='newest' ? '‚¨áÔ∏è Newest first' : '‚¨ÜÔ∏è Oldest first'; loadHistory(); });

let histTimeout;
candidate.addEventListener('input', ()=> {
  clearTimeout(histTimeout);
  histTimeout = setTimeout(()=> { if (candidate.value.trim()) loadHistory(); else historyContainer.innerHTML = '<div class="card"><em>Enter your name to view history</em></div>'; }, 700);
});

/* ========== initialize ========== */
window.addEventListener('load', async ()=> {
  if (typeof speechSynthesis !== 'undefined') {
    speechSynthesis.onvoiceschanged = ()=> { selectedVoice = chooseVoice(); };
    selectedVoice = chooseVoice();
  }
  await initMedia();
  try {
    const res = await fetch('/health');
    const health = await res.json();
    console.log('Backend health:', health);
    if (!health.whisper_loaded) console.warn('Whisper not loaded on backend');
  } catch(e) { console.warn('Health check failed', e); status.textContent = '‚ö†Ô∏è Backend connection issue'; status.className = 'status error'; }
});
</script>
</body>
</html>
